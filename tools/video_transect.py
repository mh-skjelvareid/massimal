# Imports
import ffmpeg
import pandas as pd
import geopandas
import warnings
import misc
import numpy as np
import datetime
from pathlib import Path
from tqdm import tqdm
import exiftool

# Suppress "future" warnings (issue with shapely / geopandas)
warnings.simplefilter(action='ignore', category=FutureWarning)

def image_from_video(video_input_file,image_output_file, time, image_quality=5, overwrite=True):
    """ Extract image from video at given time

    # Usage:
    image_from_video(video_input_file,image_output_file, time)

    # Required arguments:
    video_input_file:   Path to video
    image_output_file:  Path to save image to
    time:               Time in seconds (numeric)
                        (fractions with milliseconds are allowed, e.g. 5.326)

    # Optional arguments:
    image_quality:  Corresponds to ffmpeg parameter -q:v
                    Number in range 1:31 (?)
                    See ffmpeg docs.
    overwrite:      Overwrite output file if it exists.


    """

    try:
        out, _ = (
            ffmpeg
            .input(video_input_file,ss=time)
            .output(image_output_file, vframes=1, format='image2', vcodec='mjpeg', **{'q:v': image_quality}) # Consider cutting the q:v parameter?
            .run(capture_stdout=True, capture_stderr=True, overwrite_output=overwrite)
        )
    except ffmpeg.Error as e:
        print(e.stderr)


def track_csv_to_geodataframe(csv_file):
    """ Read position and timestamp from CSV file, convert to geodataframe

    # Usage:
    track_csv_to_geodataframe(csv_file)

    # Required arguments:
    csv_file:   CSV file with track data, generated by Ultra GPS Logger
                Columns "Lat", "Lng" and "Time" are used

    # Returns
    gdf:        GeoDataFrame with information extracted from CSV file
                A column called "TimeDiffSec" containing number of seconds
                elapsed from start of track is added.

    """

    # Read file (only position and timestamp)
    data = pd.read_csv(csv_file, usecols=['Lat','Lng','Time'])

    # Convert time string to datetime format, and add column with time differences
    data['Time'] = pd.to_datetime(data['Time'])
    data['TimeDiffSec'] = pd.to_timedelta(data['Time'] - data['Time'][0]).dt.total_seconds()

    # Create GeoDataFrame
    gdf = geopandas.GeoDataFrame(
        data,
        crs = 'EPSG:4326',
        geometry=geopandas.points_from_xy(data.Lng, data.Lat))

    # Return
    return gdf


def otter_csv_to_geodataframe(csv_file):
    """ Read position and timestamp from Otter CSV file

    # Usage:
    otter_csv_to_geodataframe(csv_file)

    # Required arguments:
    csv_file:   CSV file with track data, generated by Otter
                and post-processed in Matlab.
                Columns "LatDecDeg", "LongDecDeg" and "GnssUTC" are used

    # Returns
    gdf:        GeoDataFrame with information extracted from CSV file
                Columns are renamed "Lat", "Lng" and "Time"

    """

    # Read data
    data = pd.read_csv(csv_file,usecols=['LatDecDeg','LongDecDeg','GnssUTC'])
    data.columns = ['Time','Lat','Lng']                   # Rename columns
    data.Time = pd.to_datetime(data.Time,utc=True)        # Convert time string to datetime format

    # Create GeoDataFrame
    gdf = geopandas.GeoDataFrame(
        data,
        crs = 'EPSG:4326',
        geometry=geopandas.points_from_xy(data.Lng, data.Lat))

    # Return
    return gdf


def sec_to_timestring(sec):
    """ Convert number of seconds (numeric) into formatted string with minutes

    # Usage:
    timestring = sec_to_timestring(sec)

    # Required arguments:
    sec:    Number of seconds (numeric)

    # Returns:
    timestring:     String with minutes, seconds and milliseconds

    # Example
    sec_to_timestring(367.86) returns '06m07s860ms'

    """
    sec_td = datetime.timedelta(seconds = sec)
    timestring = (str(sec_td.seconds//60).zfill(2) + 'm'
                  + str(np.mod(sec_td.seconds,60)).zfill(2) + 's'
                  + str(sec_td.microseconds//1000).zfill(3) + 'ms')
    return timestring


def get_video_data(video_dir, tz='Europe/Oslo'):
    """ Get info about videos in folder, organized as dataframe

    # Usage:
    video_data = get_video_data(video_dir)

    # Arguments:
    video_dir:      Path to folder with video file(s).
                    Files are assumed to be from a single continuous "take",
                    split into files with names ordered alphabetiacally
                    according to recording order.
    
    # Keyword arguments:
    tz              Timezone for video. Default: 'Europe/Oslo'
                    To see available options:
                    > import pytz
                    > print(pytz.common_timezones)

    # Returns:
    video_data:     Pandas dataframe with columns
                    'FileName', 'DurationSec','StartTimeSec','StopTimeSec'
                    Start and stop times are relative to start of first file.

    """

    video_data = pd.DataFrame({ 'FileName':'',
                                'CreationTime':pd.Timestamp(0,tz=tz),
                                'DurationSec':float(),
                                'StartTimeSec':float(),
                                'StopTimeSec':float()},
                                 index=[])

    # Get list of video files, insert into dataframe
    # Use brackets to find both .mp4 and .MP4 files
    video_data.FileName = misc.file_pattern_search(video_dir, '*.[Mm][Pp]4')

    # Get creation time, duration and frame rate for each video file
    # Keep times timezone naive
    for ii,file in enumerate(video_data['FileName']):
        probe_data = ffmpeg.probe(file)
        video_data.loc[ii,'CreationTime'] = pd.to_datetime( \
            probe_data['streams'][0]['tags']['creation_time']). \
            tz_localize(None).tz_localize(tz)  # "Reset" to no timezone, then set timezone
        video_data.loc[ii,'DurationSec'] = pd.to_numeric(probe_data['streams'][0]['duration'])
    
    # Calculate start and stop times for each video in seconds, relative to start of video
    # Note that columns.get_loc() needs to be used below in order to access dataframs
    # by integer indices only.
    video_data.loc[0,'StartTimeSec'] = 0.0
    video_data.iloc[1:,video_data.columns.get_loc('StartTimeSec')] = np.cumsum(
        video_data.iloc[:-1,video_data.columns.get_loc('DurationSec')])
    video_data.StopTimeSec = video_data.StartTimeSec + video_data.DurationSec

    return video_data



def prepare_gdf_with_video_data(gdf,video_data, video_offset_sec=0.0):
    """ Insert video information into geodataframe, prepare for extracting images

    # Usage:
    gdf = prepare_gdf_with_video_data(gdf,video_data)

    # Arguments:
    gdf:        geodataframe with positions and timestamps
                (see track_csv_to_geodataframe())
    video_data: dataframe with video data
                (see get_video_data())
    
    # Keyword arguments:
    video_offset_sec:     number of seconds time difference between
                          video datetime (based on "CreationTime") and 
                          GNSS track datetime. Default: 0.

    # Returns
    gdf:        geodataframe with video information inserted
    """

    # Create copy of original geodataframe
    gdf = gdf.copy()
    
    # Insert additional columns
    gdf.insert(gdf.shape[1]-1,'VideoFile','')
    gdf.insert(gdf.shape[1]-1,'TimeRelToVideoStart',pd.Timedelta(0))
    gdf.insert(gdf.shape[1]-1,'TimeRelToFileStartSec',float())
    
    # Calculate time for logged positions relative to video
    gdf.TimeRelToVideoStart = gdf.Time - (video_data.iloc[0].CreationTime - pd.Timedelta(seconds=video_offset_sec))
    
    # Exclude positions outside video time window
    ind_within_video_duration = (gdf.TimeRelToVideoStart >= pd.Timedelta(0)) & (
                                 gdf.TimeRelToVideoStart <= pd.Timedelta(seconds=video_data.iloc[-1].StopTimeSec))
    gdf = gdf[ind_within_video_duration]

    # For each position, find corresponding video file and calculate time relative to start of video
    for ii in range(video_data.shape[0]):
        # Create index for rows within current video time window
        ind = (gdf.TimeRelToVideoStart >= pd.Timedelta(seconds=video_data.iloc[ii].StartTimeSec)) & (
               gdf.TimeRelToVideoStart < pd.Timedelta(seconds=video_data.iloc[ii].StopTimeSec))
        # Set video file and times for current video 
        gdf.loc[ind, 'VideoFile'] = video_data.iloc[ii].FileName
        time_rel_to_file_start = gdf.loc[ind, 'TimeRelToVideoStart'] - pd.Timedelta(seconds=video_data.iloc[ii].StartTimeSec)
        gdf.loc[ind, 'TimeRelToFileStartSec'] = time_rel_to_file_start.dt.total_seconds() 
        
    return gdf


def extract_images_from_video(gdf,image_dir):
    """ Extract images from video transect

    # Usage:
    gdf = extract_images_from_video(gdf,image_dir)

    # Required arguments:
    gdf:        geodataframe from prepare_gdf_with_video_data()
    image_dir:  path to folder where images will be stored

    # Returns:
    gdf:        geodataframe with image file names inserted
                (relative path with parent directory included)
    """

    # Create copy to avoid changing original geodataframe
    gdf = gdf.copy()
    
    # Convert datetimes and timedeltas to strings (needed to save as GPKG)
    gdf.Time = gdf.Time.dt.strftime('%Y-%m-%d %H:%M:%S.%f%z')
    gdf.TimeRelToVideoStart = gdf.TimeRelToVideoStart.astype(str)
    
    # Insert additional column for image path
    gdf.insert(gdf.shape[1]-1,'ImageFile','')

    # Loop over every row, create image and save image file name
    for ii in tqdm(range(len(gdf))):    # Use tqdm to display progress bar
        # Create file name and log it to the geodataframe
        image_file_name = Path(gdf.iloc[ii].VideoFile).stem + '_' + \
                           sec_to_timestring(gdf.iloc[ii].TimeRelToFileStartSec) + '.jpg'
        gdf.iloc[ii, gdf.columns.get_loc('ImageFile')] = str(image_file_name)  # Must use get_loc for "mixed" indexing with ints and names
        
        # Create absolute path
        abs_path = Path(image_dir,image_file_name)

        # Extract image from video and save
        image_from_video(gdf.iloc[ii].VideoFile,
                            str(abs_path),
                            gdf.iloc[ii].TimeRelToFileStartSec)

    return gdf


def filter_gdf_on_distance(gdf,sample_distance,epsg=32633, outlier_distance = 1000):
    """ Filter a geodataframe by only including new samples if position has changed
    
    # Usage:
    gdf_filtered = filter_gdf_on_distance(gdf,...)

    # Input arguments:
    gdf:                  GeoPandas GeoDataFrame object
    sample_distance       Minimum change in position in order for next sample to be included
                          Units are defined by CRS (set as EPSG code, see kwarg epsg)
    
    # Keyword arguments:
    epsg:                EPSG code (integer) for CRS to measure distance in
                         Default: 32633 (UTM 33N)
                         If epsg=None, the existing CRS for the geodataframe is used
    outlier_distance     Samples with changes in distance above this limit are not included
                         Units are defined by CRS
    
    """
    
    # Convert CRS (often necessary to get valid distance units, e.g. meters)
    if epsg is not None:
        geom = gdf.geometry.to_crs(epsg=epsg)
    else:
        geom = gdf.geometry
        
    # Iterate over all positions, and only include a new point if position 
    # has changed more than sample_distance
    mask = [0]              # Always include first point
    last_pos = geom.iloc[0] # Position at first point
    for index, position in enumerate(geom):
        dist = position.distance(last_pos)
        if (dist > sample_distance) and (dist < outlier_distance):
            mask.append(index)
            last_pos = position
    
    # Return a filtered copy of the original geodataframe
    return gdf.iloc[mask]


def get_image_timestamps(image_paths):
    """ Get subsecond-accuracy timestamps for every image file in a list
    
    # Input parameters:
    image_paths:
        List of image paths, used by exiftool method ExifToolHelper.get_metadata()
    
    # Returns:
    image_paths_and_timestamps:
        List of tuples containing (image_path, image_timestamp_string)
    """
    with exiftool.ExifToolHelper() as et:
        metadata = et.get_metadata(image_paths)
    image_paths_and_timestamps = [(im_file.name,md['Composite:SubSecCreateDate']) 
                                  for (im_file,md) in zip(image_paths,metadata) 
                                  if 'Composite:SubSecCreateDate' in md]
    return image_paths_and_timestamps


def get_otter_image_positions(otter_gdf,image_paths_and_timestamps,
                              dt_format = r'%Y:%m:%d %H:%M:%S.%f',
                              time_tolerance = datetime.timedelta(seconds=1)):
    """ Search Otter geodataframe for positions closest to image (in time)
    
    # Input arguments:
    otter_gdf:      
        GDF created from Otter CSV (see otter_csv_to_geodataframe())
        Only column "Time" (containing UTC datetime objects) is used
    image_paths_and_timestamps:
        List of tuples containing (image_path, image_timestamp_string)
    
    # Returns
    image_gdf:
    
    """

    # TODO: Test this function!
    
    # Extract timestamps and convert to datetime objects
    image_datetimes = [pd.to_datetime(dt,format=dt_format,utc=True) for (_,dt) in image_paths_and_timestamps]

    # Find indices for Otter timestamps that are closest to image timestamps
    closest_time_index = pd.Index(otter_gdf['Time']).get_indexer(image_datetimes,method='nearest',
                                                                 tolerance=time_tolerance)
    
    # Remove images that don't have any matches within the time tolerance
    image_paths = [p for ((p,_),im_index) in zip(image_paths_and_timestamps,closest_time_index)
                   if im_index >= 0] # Images without match get index -1
    closest_time_index = closest_time_index[closest_time_index>=0]
    assert len(image_paths) == len(closest_time_index)

    # Create copy of Otter gdf which only contains rows corresponding to images
    image_gdf = otter_gdf.iloc[closest_time_index]
    
    # Insert additional column for image path
    image_gdf.insert(image_gdf.shape[1]-1,'ImageFile','')
    image_gdf.iloc[:,image_gdf.columns.get_loc('ImageFile')] = image_paths

    return image_gdf

