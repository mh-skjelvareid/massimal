# Imports
import ffmpeg
import pandas as pd
import geopandas
import warnings
import misc
import numpy as np
import datetime
from pathlib import Path
from tqdm import tqdm

# Suppress "future" warnings (issue with shapely / geopandas)
warnings.simplefilter(action='ignore', category=FutureWarning)

def image_from_video(video_input_file,image_output_file, time, image_quality=5, overwrite=True):
    """ Extract image from video at given time

    # Usage:
    image_from_video(video_input_file,image_output_file, time)

    # Required arguments:
    video_input_file:   Path to video
    image_output_file:  Path to save image to
    time:               Time in seconds (numeric)
                        (fractions with milliseconds are allowed, e.g. 5.326)

    # Optional arguments:
    image_quality:  Corresponds to ffmpeg parameter -q:v
                    Number in range 1:31 (?)
                    See ffmpeg docs.
    overwrite:      Overwrite output file if it exists.


    """

    try:
        out, _ = (
            ffmpeg
            .input(video_input_file,ss=time)
            .output(image_output_file, vframes=1, format='image2', vcodec='mjpeg', **{'q:v': image_quality}) # Consider cutting the q:v parameter?
            .run(capture_stdout=True, capture_stderr=True, overwrite_output=overwrite)
        )
    except ffmpeg.Error as e:
        print(e.stderr)


def track_csv_to_geodataframe(csv_file):
    """ Read position and timestamp from CSV file, convert to geodataframe

    # Usage:
    track_csv_to_geodataframe(csv_file)

    # Required arguments:
    csv_file:   CSV file with track data, generated by Ultra GPS Logger
                Columns "Lat", "Lng" and "Time" are used

    # Returns
    gdf:        GeoDataFrame with information extracted from CSV file
                A column called "TimeDiffSec" containing number of seconds
                elapsed from start of track is added.

    """

    # Read file (only position and timestamp)
    data = pd.read_csv(csv_file, usecols=['Lat','Lng','Time'])

    # Convert time string to datetime format, and add column with time differences
    data['Time'] = pd.to_datetime(data['Time'])
    data['TimeDiffSec'] = pd.to_timedelta(data['Time'] - data['Time'][0]).dt.total_seconds()

    # Create GeoDataFrame
    gdf = geopandas.GeoDataFrame(
        data,
        crs = 'EPSG:4326',
        geometry=geopandas.points_from_xy(data.Lng, data.Lat))

    # Return
    return gdf


def otter_csv_to_geodataframe(csv_file):
    """ Read position and timestamp from Otter CSV file

    # Usage:
    otter_csv_to_geodataframe(csv_file)

    # Required arguments:
    csv_file:   CSV file with track data, generated by Otter
                and post-processed in Matlab.
                Columns "LatDecDeg", "LongDecDeg" and "GnssUTC" are used

    # Returns
    gdf:        GeoDataFrame with information extracted from CSV file
                Columns are renamed "Lat", "Lng" and "Time"

    """

    # Read data
    data = pd.read_csv(csv_file,usecols=['LatDecDeg','LongDecDeg','GnssUTC'])
    data.columns = ['Time','Lat','Lng']                   # Rename columns
    data.Time = pd.to_datetime(data.Time,utc=True)        # Convert time string to datetime format

    # Create GeoDataFrame
    gdf = geopandas.GeoDataFrame(
        data,
        crs = 'EPSG:4326',
        geometry=geopandas.points_from_xy(data.Lng, data.Lat))

    # Return
    return gdf


def sec_to_timestring(sec):
    """ Convert number of seconds (numeric) into formatted string with minutes

    # Usage:
    timestring = sec_to_timestring(sec)

    # Required arguments:
    sec:    Number of seconds (numeric)

    # Returns:
    timestring:     String with minutes, seconds and milliseconds

    # Example
    sec_to_timestring(367.86) returns '06m07s860ms'

    """
    sec_td = datetime.timedelta(seconds = sec)
    timestring = (str(sec_td.seconds//60).zfill(2) + 'm'
                  + str(np.mod(sec_td.seconds,60)).zfill(2) + 's'
                  + str(sec_td.microseconds//1000).zfill(3) + 'ms')
    return timestring


def get_video_data(video_dir, tz='Europe/Oslo'):
    """ Get info about videos in folder, organized as dataframe

    # Usage:
    video_data = get_video_data(video_dir)

    # Arguments:
    video_dir:      Path to folder with video file(s).
                    Files are assumed to be from a single continuous "take",
                    split into files with names ordered alphabetiacally
                    according to recording order.
    
    # Keyword arguments:
    tz              Timezone for video. Default: 'Europe/Oslo'
                    To see available options:
                    > import pytz
                    > print(pytz.common_timezones)

    # Returns:
    video_data:     Pandas dataframe with columns
                    'FileName', 'DurationSec','StartTimeSec','StopTimeSec'
                    Start and stop times are relative to start of first file.

    """

    video_data = pd.DataFrame({ 'FileName':'',
                                'CreationTime':pd.Timestamp(0,tz=tz),
                                'DurationSec':float(),
                                'StartTimeSec':float(),
                                'StopTimeSec':float()},
                                 index=[])

    # Get list of video files, insert into dataframe
    # Use brackets to find both .mp4 and .MP4 files
    video_data.FileName = misc.file_pattern_search(video_dir, '*.[Mm][Pp]4')

    # Get creation time, duration and frame rate for each video file
    # Keep times timezone naive
    for ii,file in enumerate(video_data['FileName']):
        probe_data = ffmpeg.probe(file)
        video_data.loc[ii,'CreationTime'] = pd.to_datetime( \
            probe_data['streams'][0]['tags']['creation_time']). \
            tz_localize(None).tz_localize(tz)  # "Reset" to no timezone, then set timezone
        video_data.loc[ii,'DurationSec'] = pd.to_numeric(probe_data['streams'][0]['duration'])
    
    # Calculate start and stop times for each video in seconds, relative to start of video
    # Note that columns.get_loc() needs to be used below in order to access dataframs
    # by integer indices only.
    video_data.loc[0,'StartTimeSec'] = 0.0
    video_data.iloc[1:,video_data.columns.get_loc('StartTimeSec')] = np.cumsum(
        video_data.iloc[:-1,video_data.columns.get_loc('DurationSec')])
    video_data.StopTimeSec = video_data.StartTimeSec + video_data.DurationSec

    return video_data



def prepare_gdf_with_video_data(gdf,video_data, video_time_offset=pd.Timedelta(0)):
    """ Insert video information into geodataframe, prepare for extracting images

    # Usage:
    gdf = prepare_gdf_with_video_data(gdf,video_data)

    # Arguments:
    gdf:        geodataframe with positions and timestamps
                (see track_csv_to_geodataframe())
    video_data: dataframe with video data
                (see get_video_data())
    
    # Keyword arguments:
    video_time_offset:    pandas.Timedelta object with time difference between
                          video datetime ("CreationTime") and GNSS track datetime.
                          Example: GoPro camera at Norwegian local time and 
                          daylight saving time is 2 hours "in front of"
                          GNNS using UTC time, resulting in
                          video_time_offset = pandas.Timedelta(hours=2)

    # Returns
    gdf:        geodataframe with video information inserted
    """

    # Create copy of original geodataframe
    gdf = gdf.copy()
    
    # Insert additional columns
    gdf.insert(gdf.shape[1]-1,'VideoFile','')
    gdf.insert(gdf.shape[1]-1,'TimeRelToVideoStart',pd.Timedelta(0))
    gdf.insert(gdf.shape[1]-1,'TimeRelToFileStartSec',float())
    
    # Calculate time for logged positions relative to video
    gdf.TimeRelToVideoStart = gdf.Time - (video_data.iloc[0].CreationTime - video_time_offset)
    
    # Exclude positions outside video time window
    ind_within_video_duration = (gdf.TimeRelToVideoStart >= pd.Timedelta(0)) & (
                                 gdf.TimeRelToVideoStart <= pd.Timedelta(seconds=video_data.iloc[-1].StopTimeSec))
    gdf = gdf[ind_within_video_duration]

    # For each position, find corresponding video file and calculate time relative to start of video
    for ii in range(video_data.shape[0]):
        # Create index for rows within current video time window
        ind = (gdf.TimeRelToVideoStart >= pd.Timedelta(seconds=video_data.iloc[ii].StartTimeSec)) & (
               gdf.TimeRelToVideoStart < pd.Timedelta(seconds=video_data.iloc[ii].StopTimeSec))
        # Set video file and times for current video 
        gdf.loc[ind, 'VideoFile'] = video_data.iloc[ii].FileName
        time_rel_to_video_start = gdf.loc[ind, 'TimeRelToVideoStart'] - pd.Timedelta(seconds=video_data.iloc[ii].StartTimeSec)
        gdf.loc[ind, 'TimeRelToFileStartSec'] = time_rel_to_video_start.dt.total_seconds() #gdf.loc[ind, 'TimeRelToVideoStart'] - pd.Timedelta(seconds=video_data.iloc[ii].StartTimeSec)
        
    return gdf


def extract_images_from_video(gdf,image_dir):
    """ Extract images from video transect

    # Usage:
    gdf = extract_images_from_video(gdf,image_dir)

    # Required arguments:
    gdf:        geodataframe from prepare_gdf_with_video_data()
    image_dir:  path to folder where images will be stored

    # Returns:
    gdf:        geodataframe with image file names inserted
                (relative path with parent directory included)
    """

    # Create copy to avoid changing original geodataframe
    gdf = gdf.copy()
    
    # Convert datetimes and timedeltas to strings (needed to save as GPKG)
    gdf.Time = gdf.Time.dt.strftime('%Y-%m-%d %H:%M:%S.%f%z')
    gdf.TimeRelToVideoStart = gdf.TimeRelToVideoStart.astype(str)
    
    # Insert additional column for image path
    gdf.insert(gdf.shape[1]-1,'ImageFile','')

    # Loop over every row, create image and save image file name
    for ii in tqdm.tqdm(range(len(gdf))):    # Use tqdm to display progress bar
        # Create file name and log it to the geodataframe
        image_file_name = pathlib.Path(gdf.iloc[ii].VideoFile).stem + '_' + \
                           sec_to_timestring(gdf.iloc[ii].TimeRelToFileStartSec) + '.jpg'
        gdf.iloc[ii, gdf.columns.get_loc('ImageFile')] = str(image_file_name)  # Must use get_loc for "mixed" indexing with ints and names
        
        # Create absolute path
        abs_path = pathlib.Path(image_dir,image_file_name)

        # Extract image from video and save
        image_from_video(gdf.iloc[ii].VideoFile,
                            str(abs_path),
                            gdf.iloc[ii].TimeRelToFileStartSec)

    return gdf


def filter_gdf_on_distance(gdf,sample_distance,epsg=32633, inplace=False, outlier_distance = 1000):
    """ Filter a geodataframe by only including new samples if position has changed
    
    # Usage:
    gdf_filtered = filter_gdf_on_distance(gdf,...)

    # Input arguments:
    gdf:                  GeoPandas GeoDataFrame object
    sample_distance       Minimum change in position in order for next sample to be included
                          Units are defined by CRS (set as EPSG code, see kwarg epsg)
    
    # Keyword arguments:
    epsg:                EPSG code (integer) for CRS to measure distance in
                         Default: 32633 (UTM 33N)
                         If epsg=None, the existing CRS for the geodataframe is used
    outlier_distance     Samples with changes in distance above this limit are not included
                         Units are defined by CRS
    
    """
    
    # Convert CRS (often necessary to get valid distance units, e.g. meters)
    if epsg is not None:
        geom = gdf.geometry.to_crs(epsg=epsg)
    else:
        geom = gdf.geometry
        
    # Iterate over all positions, and only include a new point if position 
    # has changed more than sample_distance
    mask = [0]           # Always include first point
    last_pos = geom[0]   # Position at first point
    for index, position in enumerate(geom):
        dist = position.distance(last_pos)
        if (dist > sample_distance) and (dist < outlier_distance):
            mask.append(index)
            last_pos = position
    
    # Return a filtered copy of the original geodataframe
    return gdf.iloc[mask]
