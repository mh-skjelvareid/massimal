# Imports
import ffmpeg
import pandas as pd
import geopandas
import warnings
import misc
import numpy as np
import datetime
from pathlib import Path
from tqdm import tqdm

# Suppress "future" warnings (issue with shapely / geopandas)
warnings.simplefilter(action='ignore', category=FutureWarning)

def image_from_video(video_input_file,image_output_file, time, image_quality=5, overwrite=True):
    """ Extract image from video at given time

    # Usage:
    image_from_video(video_input_file,image_output_file, time)

    # Required arguments:
    video_input_file:   Path to video
    image_output_file:  Path to save image to
    time:               Time in seconds (numeric)
                        (fractions with milliseconds are allowed, e.g. 5.326)

    # Optional arguments:
    image_quality:  Corresponds to ffmpeg parameter -q:v
                    Number in range 1:31 (?)
                    See ffmpeg docs.
    overwrite:      Overwrite output file if it exists.


    """

    try:
        out, _ = (
            ffmpeg
            .input(video_input_file,ss=time)
            .output(image_output_file, vframes=1, format='image2', vcodec='mjpeg', **{'q:v': image_quality}) # Consider cutting the q:v parameter?
            .run(capture_stdout=True, capture_stderr=True, overwrite_output=overwrite)
        )
    except ffmpeg.Error as e:
        print(e.stderr)


def track_csv_to_geodataframe(csv_file):
    """ Read position and timestamp from CSV file, convert to geodataframe

    # Usage:
    track_csv_to_geodataframe(csv_file)

    # Required arguments:
    csv_file:   CSV file with track data, generated by Ultra GPS Logger
                Columns "Lat", "Lng" and "Time" are used

    # Returns
    gdf:        GeoDataFrame with information extracted from CSV file
                A column called "TimeDiffSec" containing number of seconds
                elapsed from start of track is added.

    """

    # Read file (only position and timestamp)
    data = pd.read_csv(csv_file, usecols=['Lat','Lng','Time'])

    # Convert time string to datetime format, and add column with time differences
    data['Time'] = pd.to_datetime(data['Time'])
    data['TimeDiffSec'] = pd.to_timedelta(data['Time'] - data['Time'][0]).dt.total_seconds()

    # Create GeoDataFrame
    gdf = geopandas.GeoDataFrame(
        data,
        crs = 'EPSG:4326',
        geometry=geopandas.points_from_xy(data.Lng, data.Lat))

    # Return
    return gdf


def sec_to_timestring(sec):
    """ Convert number of seconds (numeric) into formatted string with minutes

    # Usage:
    timestring = sec_to_timestring(sec)

    # Required arguments:
    sec:    Number of seconds (numeric)

    # Returns:
    timestring:     String with minutes, seconds and milliseconds

    # Example
    sec_to_timestring(367.86) returns '06m07s860ms'

    """
    sec_td = datetime.timedelta(seconds = sec)
    timestring = (str(sec_td.seconds//60).zfill(2) + 'm'
                  + str(np.mod(sec_td.seconds,60)).zfill(2) + 's'
                  + str(sec_td.microseconds//1000).zfill(3) + 'ms')
    return timestring


def get_video_data(video_dir):
    """ Get info about videos in folder, organized as dataframe

    # Usage:
    video_data = get_video_data(video_dir)

    # Required:
    video_dir:      Path to folder with video file(s).
                    Files are assumed to be from a single continuous "take",
                    split into files with names ordered alphabetiacally
                    according to recording order.

    # Returns:
    video_data:     Pandas dataframe with columns
                    'FileName', 'DurationSec','StartTimeSec','StopTimeSec'
                    Start and stop times are relative to start of first file.

    """

    video_data = pd.DataFrame({ 'FileName':'',
                                'DurationSec':float(),
                                'StartTimeSec':float(),
                                'StopTimeSec':float()},
                                 index=[])

    # Get list of video files, insert into dataframe
    # Use brackets to find both .mp4 and .MP4 files
    video_data['FileName'] = misc.file_pattern_search(video_dir, '*.[Mm][Pp]4')

    # Get duration and frame rate for each video file
    for ii,file in enumerate(video_data['FileName']):
        probe_data = ffmpeg.probe(file)
        video_data.loc[ii,'DurationSec'] = pd.to_numeric(probe_data['streams'][0]['duration'])

    video_data.iloc[0,video_data.columns.get_loc('StartTimeSec')] = 0.0
    video_data.iloc[1:,video_data.columns.get_loc('StartTimeSec')] = np.cumsum(
        video_data.iloc[:-1,video_data.columns.get_loc('DurationSec')])
    video_data['StopTimeSec'] = video_data['StartTimeSec'] + video_data['DurationSec']

    return video_data



def prepare_gdf_with_video_data(gdf,video_data):
    """ Insert video information into geodataframe, prepare for extracting images

    # Usage:
    gdf = prepare_gdf_with_video_data(gdf,video_data)

    # Required arguments:
    gdf:        geodataframe with positions and timestamps
                (see track_csv_to_geodataframe())
    video_data: dataframe with video data
                (see get_video_data())

    # Returns
    gdf:        geodataframe with video information inserted
    """

    # Insert additional columns
    gdf.insert(gdf.shape[1]-1,'VideoFile','')
    gdf.insert(gdf.shape[1]-1,'VideoRelTime',float())

    # Remove logged positions without video data
    ind_within_video_duration = (gdf['TimeDiffSec'] <= video_data['StopTimeSec'].iloc[-1])
    gdf = gdf[ind_within_video_duration]

    # For each position, find corresponding video file and calculate time relative to start of video
    for ii in range(video_data.shape[0]):
        ind = (gdf['TimeDiffSec'] >= video_data['StartTimeSec'][ii]) & (gdf['TimeDiffSec'] < video_data['StopTimeSec'][ii])
        gdf.loc[ind, 'VideoFile'] = video_data['FileName'][ii]
        gdf.loc[ind, 'VideoRelTime'] = gdf.loc[ind, 'TimeDiffSec'] - video_data['StartTimeSec'][ii]

    return gdf


def extract_images_from_video(gdf,image_dir):
    """ Extract images from video transect

    # Usage:
    gdf = extract_images_from_video(gdf,image_dir)

    # Required arguments:
    gdf:        geodataframe from prepare_gdf_with_video_data()
    image_dir:  path to folder where images will be stored

    # Returns:
    gdf:        geodataframe with image file names inserted
                (relative path with parent directory included)
    """

    # Insert additional column for image path
    gdf.insert(gdf.shape[1]-1,'ImageFile','')

    # Loop over every row, create image and save image file name
    for ii in tqdm(range(len(gdf))):    # Use tqdm to display progress bar

        image_file_name = (Path(gdf.iloc[ii]['VideoFile']).stem + '_' +
                           sec_to_timestring(gdf.iloc[ii]['VideoRelTime']) + '.jpg')

        gdf.iloc[ii, gdf.columns.get_loc('ImageFile')] = str(image_file_name)

        abs_path = Path(image_dir,image_file_name)
        #rel_path = Path(abs_path.parent.name, image_file_name)

        # Extract image from video and save
        image_from_video(gdf.iloc[ii]['VideoFile'],
                            str(abs_path),
                            gdf.iloc[ii]['VideoRelTime'])

    return gdf
